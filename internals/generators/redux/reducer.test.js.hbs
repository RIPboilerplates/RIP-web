import { fromJS } from 'immutable'
import { reducer } from '../reducer'

import {
  {{ constantCase actionName }}_PENDING,
  {{ constantCase actionName }}_FULFILLED,
  {{ constantCase actionName }}_REJECTED,
  INITIAL_STATE,
} from '../constants'

describe('{{ camelCase name }} reducer', () => {
  let result
  let initialState
  let store
  let payload
  let error

  beforeEach(() => {
    payload = null
    store = null
    error = 'error'
    initialState = { ...INITIAL_STATE }
    result = { ...INITIAL_STATE }
  })

  const setFetching = () => {
    result.fetching = true
    result.fetched = false
  }

  const setFetched = () => {
    result.fetching = false
    result.fetched = true
  }

  it('returns the initial state', () => {
    expect(reducer(undefined, {}).toJS()).toEqual(INITIAL_STATE)
  })

  it('returns state for {{ constantCase actionName }}_PENDING', () => {
    setFetching()

    store = reducer(fromJS(initialState), { type: {{ constantCase actionName }}_PENDING })
    expect(store.toJS()).toEqual(result)
  })

  it('returns state for {{ constantCase actionName }}_FULFILLED', () => {
    setFetched()
    result.{{ stateVariable}} = 'YAY!!'

    store = reducer(fromJS(initialState), { type: {{ constantCase actionName }}_FULFILLED, payload: 'YAY!!' })
    expect(store.toJS()).toEqual(result)
  })

  it('returns state for {{ constantCase actionName }}_REJECTED', () => {
    setFetched()
    result.error = error

    store = reducer(fromJS(initialState), { type: {{ constantCase actionName }}_REJECTED, payload: error })
    expect(store.toJS()).toEqual(result)
  })
})
